Install & set up kong on kubernetes
-------------------------------------



1. install docker desktop on local machine and enable/start kubernetes



2. deploy kong ingress controller



   $ kubectl apply -f https://bit.ly/kong-ingress

   or

   $ curl -sL https://bit.ly/kong-ingress | kubectl create -f -



   NOTE: If need to undo this step, and remove all resources set up using the above command,



       $ kubectl delete -f https://bit.ly/kong-ingress





3. view new kong resources



$ kubectl get all -n kong

NAME                                READY   STATUS      RESTARTS   AGE

pod/ingress-kong-6548cc5f85-fvwzj   2/2     Running     3          14h

pod/kong-migrations-sb5fl           0/1     Completed   0          14h

pod/postgres-0                      1/1     Running     1          14h



NAME                              TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE

service/kong-proxy                LoadBalancer   10.102.81.67    localhost     80:30390/TCP,443:31491/TCP   14h

service/kong-validation-webhook   ClusterIP      10.103.130.71   <none>        443/TCP                      14h

service/postgres                  ClusterIP      10.97.143.8     <none>        5432/TCP                     14h



NAME                           READY   UP-TO-DATE   AVAILABLE   AGE

deployment.apps/ingress-kong   1/1     1            1           14h



NAME                                      DESIRED   CURRENT   READY   AGE

replicaset.apps/ingress-kong-6548cc5f85   1         1         1       14h



NAME                        READY   AGE

statefulset.apps/postgres   1/1     14h



NAME                        COMPLETIONS   DURATION   AGE

job.batch/kong-migrations   1/1           61s        14h





   NOTE that the pods are up and running (ingress and postgres). he migration pod has run and has completed.





4. check the service



$ kubectl describe svc -n kong kong-proxy

Name:                     kong-proxy

Namespace:                kong

Labels:                   <none>

Annotations:              kubectl.kubernetes.io/last-applied-configuration:

   {"apiVersion":"v1","kind":"Service","metadata":{"annotations":{"service.beta.kubernetes.io/aws-load-balancer-backend-protocol":"tcp","serv...

 service.beta.kubernetes.io/aws-load-balancer-backend-protocol: tcp

 service.beta.kubernetes.io/aws-load-balancer-type: nlb

Selector:                 app=ingress-kong

Type:                     LoadBalancer

IP:                       10.102.81.67

LoadBalancer Ingress:     localhost

Port:                     proxy  80/TCP

TargetPort:               8000/TCP

NodePort:                 proxy  30390/TCP

Endpoints:                10.1.0.11:8000

Port:                     proxy-ssl  443/TCP

TargetPort:               8443/TCP

NodePort:                 proxy-ssl  31491/TCP

Endpoints:                10.1.0.11:8443

Session Affinity:         None

External Traffic Policy:  Local

HealthCheck NodePort:     32701

Events:                   <none>



        or more compact:



$ kubectl get service -n kong kong-proxy

NAME         TYPE           CLUSTER-IP     EXTERNAL-IP   PORT(S)                      AGE

kong-proxy   LoadBalancer   10.102.81.67   localhost     80:30390/TCP,443:31491/TCP   14h



    We'll use this info to set up the PROXY env var next





5. set up proxy env var, this will be the address we will use to send requests to the kubernetes cluster



   $ export PROXY_IP=http://localhost:80





6. If everything is setup correctly, making a request to Kong should return back a HTTP 404 Not Found.



$ curl -i $PROXY_IP

HTTP/1.1 404 Not Found

Date: Fri, 21 Jun 2019 17:01:07 GMT

Content-Type: application/json; charset=utf-8

Connection: keep-alive

Content-Length: 48

Server: kong/1.1.2



{"message":"no Route matched with those values"}



   This is expected since Kong doesn't know how to proxy the request yet.



7. Set up a service behind the ingress server, for testing just use an echo-server that just returns info about the pod and HTTP request.



      $ curl -sL bit.ly/echo-server | kubectl apply -f -



8. Now set up an ingress rule to proxy through to our new echo-server:



$ echo "

apiVersion: extensions/v1beta1

kind: Ingress

metadata:

 name: demo

spec:

 rules:

 - http:

     paths:

     - path: /foo

backend:

 serviceName: echo

 servicePort: 80

" | kubectl apply -f -

ingress.extensions/demo created



9. With the echo server and ingress rule in place, can now make a call through:



      $ curl -i $PROXY_IP/foo



HTTP/1.1 200 OK

Content-Type: text/plain; charset=UTF-8

Transfer-Encoding: chunked

Connection: keep-alive

Date: Wed, 16 Oct 2019 07:42:13 GMT

Server: echoserver

X-Kong-Upstream-Latency: 1

X-Kong-Proxy-Latency: 36

Via: kong/1.3.0







Hostname: echo-758859bbfb-sgjfx



Pod Information:

node name: docker-desktop

pod name: echo-758859bbfb-sgjfx

pod namespace: default

pod IP: 10.1.0.17



Server values:

server_version=nginx: 1.12.2 - lua: 10010



Request Information:

client_address=10.1.0.11

method=GET

real path=/

query=

request_version=1.1

request_scheme=http

request_uri=http://localhost:8080/



Request Headers:

accept=*/*

connection=keep-alive

host=localhost

user-agent=curl/7.54.0

x-forwarded-for=192.168.65.3

x-forwarded-host=localhost

x-forwarded-port=8000

x-forwarded-proto=http

x-real-ip=192.168.65.3



Request Body:

-no body in request-





10. Setting up and using Kong plugins



    a) Setup a KongPlugin resource:



$ echo "

apiVersion: configuration.konghq.com/v1

kind: KongPlugin

metadata:

 name: request-id

config:

 header_name: my-request-id

plugin: correlation-id

" | kubectl apply -f -

kongplugin.configuration.konghq.com/request-id created



    b) Create a new Ingress resource which uses this plugin:



$ echo "

apiVersion: extensions/v1beta1

kind: Ingress

metadata:

 name: demo-example-com

 annotations:

   plugins.konghq.com: request-id

spec:

 rules:

 - host: example.com

   http:

     paths:

     - path: /bar

backend:

 serviceName: echo

 servicePort: 80

" | kubectl apply -f -

ingress.extensions/demo-example-com created



     The above resource directs Kong to exectue the request-id plugin whenever a request is proxied matching any rule defined in the resource.



   c) Test, by sending a request to Kong:



$ curl -i -H "Host: example.com" $PROXY_IP/bar/sample

HTTP/1.1 200 OK

Content-Type: text/plain; charset=UTF-8

Transfer-Encoding: chunked

Connection: keep-alive

Date: Wed, 16 Oct 2019 09:19:39 GMT

Server: echoserver

X-Kong-Upstream-Latency: 3

X-Kong-Proxy-Latency: 14

Via: kong/1.3.0







Hostname: echo-758859bbfb-lsqw7



Pod Information:

node name: docker-desktop

pod name: echo-758859bbfb-lsqw7

pod namespace: default

pod IP: 10.1.0.16



Server values:

server_version=nginx: 1.12.2 - lua: 10010



Request Information:

client_address=10.1.0.11

method=GET

real path=/sample

query=

request_version=1.1

request_scheme=http

request_uri=http://example.com:8080/sample



Request Headers:

accept=*/*

connection=keep-alive

host=example.com

my-request-id=f7396a48-236b-40dd-b032-8d314bde80f7#1

user-agent=curl/7.54.0

x-forwarded-for=192.168.65.3

x-forwarded-host=example.com

x-forwarded-port=8000

x-forwarded-proto=http

x-real-ip=192.168.65.3



Request Body:

-no body in request-





      NOTE: The my-request-id can be seen in the request received by echo-server.

            It is injected by Kong as the request matches one of the Ingress rules defined in demo-example-com resource.





11. Set up a plugin to run at Service Level



    The previous section describes how a plugin can be applied at a request level, but Kong Ingress allows plugins to be executed

    on a service level, meaning:



       * Kong will execute a plugin whenever a request is sent to a specific k8s service, no matter which Ingress path it came from.



    a) create the kong plugin resource:



$ echo "

apiVersion: configuration.konghq.com/v1

kind: KongPlugin

metadata:

 name: rl-by-ip

config:

 minute: 5

 limit_by: ip

 policy: local

plugin: rate-limiting

" | kubectl apply -f -

kongplugin.configuration.konghq.com/rl-by-ip created



    b) Next, apply the plugins.konghq.com annotation on the Kubernetes Service that needs rate-limiting:

       IN THIS CASE, its the ECHO service



$ kubectl patch svc echo \

 -p '{"metadata":{"annotations":{"plugins.konghq.com": "rl-by-ip\n"}}}'



    c) Now, any request sent to this service will be protected by a rate-limit enforced by Kong:



$ curl -I $PROXY_IP/foo

HTTP/1.1 200 OK

Content-Type: text/plain; charset=UTF-8

Connection: keep-alive

Date: Fri, 21 Jun 2019 18:25:49 GMT

Server: echoserver

X-RateLimit-Limit-minute: 5

X-RateLimit-Remaining-minute: 2

X-Kong-Upstream-Latency: 0

X-Kong-Proxy-Latency: 4

Via: kong/1.1.2



$ curl -I -H "Host: example.com" $PROXY_IP/bar/sample

HTTP/1.1 200 OK

Content-Type: text/plain; charset=UTF-8

Connection: keep-alive

Date: Fri, 21 Jun 2019 18:28:30 GMT

Server: echoserver

X-RateLimit-Limit-minute: 5

X-RateLimit-Remaining-minute: 4

X-Kong-Upstream-Latency: 1

X-Kong-Proxy-Latency: 2

Via: kong/1.1.2





-------------------------------------

NEXT: hook up to auth server



NOTE: In this example we'll be using the OpenID Connect (OIDC) plug-in for Kong, which is only available for Kong Enterprise









====================



Set up kuberbetes dashboard on docker desktop



1. Download the dashboard yaml



      $ wget https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml



2. For development, disable user login, so edit the yaml downloaded in 1.



   a) Locate the container -> args section under the Dashboard-Deployment section (around line 116) and add the following command line arguments:



--enable-skip-login

--disable-settings-authorizer



   b) Your modified args section should look like the following



spec:

     containers:

     - name: kubernetes-dashboard

image: k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1

ports:

- containerPort: 8443

 protocol: TCP

args:

 - --enable-skip-login

 - --disable-settings-authorizer        

 - --auto-generate-certificates

 # Uncomment the following line to manually specify Kubernetes API server Host

 # If not specified, Dashboard will attempt to auto discover the API server and connect

 # to it. Uncomment only if the default does not work.

 # - --apiserver-host=http://my-address:port

volumeMounts:

- name: kubernetes-dashboard-certs

 mountPath: /certs





    c) save the modified dashboard yaml



3. deploy the dashboard:



      $ kubectl apply -f ./kubernetes-dashboard.yaml



4. Check all resources :



      $ kubectl get all --all-namespaces | grep dash



kube-system   pod/kubernetes-dashboard-6475c46ff6-g26v6    1/1     Running     0          23s

kube-system   service/kubernetes-dashboard      ClusterIP      10.106.94.39    <none>        443/TCP                      23s

kube-system   deployment.apps/kubernetes-dashboard   1/1     1            1           23s

kube-system   replicaset.apps/kubernetes-dashboard-6475c46ff6   1         1         1       23s



5. To access the dashboard from your local workstation you must create a secure channel to your Kubernetes cluster:



      $ kubectl proxy





6. Can now access Dashboard at:



      http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/.



   Set the namespaces tab to All namespaces to see everything.





-------------------------------



KONG
=====



signed up for a 15 day free trial for Kong-Enterprise (16-oct-2019).



This was needed to gain access to the OpenID Connect (OIDC) plug-in for Kong.



Key Concepts

--------------

The following concepts have a special meaning in Kong Enterprise:



Plugin: a plugin executing actions inside Kong before or after a request has been proxied to the upstream API.



Workspace: a private, segmented part of a shared Kong cluster that allows a particular team to access its own Admin API entities separately from other teams.



Admin: a Kong Enterprise user capable of accessing Admin API entities based on a set of Permissions.



Permission: an ability to create, read, update, or destroy an Admin API entity defined by endpoints.



Role: a set of Permissions that may be reused and assigned to Admins.



Super Admin: an Admin whose Role has the Permission to:

invite and disable other Admin accounts

assign and revoke Roles

create new Roles with custom Permissions

create new Workspaces

Service: the Admin API entity representing an external upstream API or microservice.



Route: the Admin API entity representing a way to map downstream requests to upstream services.



Consumer: the Admin API entity representing a developer or machine using the API. When using Kong, a Consumer only communicates with Kong which proxies every call to the said upstream API.









--------------------------------------------------------

How to set up Kong Enterprise on Docker Desktop



1. sign up for kong-enterprise free trial here :

     https://konghq.com/free-trial



2. shortly after, you'll get an email titled 'Kong Enterprise Edition Trial - Download and Install Instructions'



3. in this mail, look for 1-Download Kong EE section, then find the kubernetes entry, click to download:

     - kong-enterprise-edition-ft-0.36.tar.gz



   move this to a kong-ee sandbox folder



4. in the same mail, look  for 2-License File, and click to download license:

     - license-00Q1K0000187inPUAQ_a1V1K000007KdaEUAS.json



   move this to your kong-ee sandbox folder



5. still in the mail, go back to the 1-Download Kong EE section, then find the kubernetes entry, now click on the 'Documentation' link, takes you to

      - https://docs.konghq.com/install/kubernetes/



6. Click on the 'Kong via Manifest Files' link



7. Find the 'Kong Kubernetes repository' link, click it, and download the zip version of the repr and save it to your kong-ee sandbox folder



8. Back to the install guide (Kong via Manifest Files) & also get a terminal open in your kong-ee sandbox folder, which should contain:

drwxr-xr-x@ 23 agrahame  staff        736 15 Oct 20:44 kong-dist-kubernetes-master

-rw-r--r--@  1 agrahame  staff      16033 18 Oct 12:13 kong-dist-kubernetes-master.zip

-rw-r--r--@  1 agrahame  staff  155027837 18 Oct 12:15 kong-enterprise-edition-ft-0.36.tar.gz

-rw-r--r--@  1 agrahame  staff        416 18 Oct 12:16 license-00Q1K0000187inPUAQ_a1V1K000007KdaEUAS.json



After unzipping the repo zip (kong-dist-kubernetes-master), cd to the directory, and clean up before we start (just in case anything is hanging around from a previous session:
$ make cleanup



Now check there are no kong resources:
$ kubectl get all -n kong

No resources found.



Set up kong/postgres:
$ make run_postgres



kubectl apply -f kong-namespace.yaml

namespace/kong created

./setup_certificate.sh

Generating a 2048 bit RSA private key

.........................................................+++

.........+++

writing new private key to 'privkey.pem'

-----

certificatesigningrequest.certificates.k8s.io/kong-control-plane.kong.svc created

certificatesigningrequest.certificates.k8s.io/kong-control-plane.kong.svc approved

secret/kong-control-plane.kong.svc created

certificatesigningrequest.certificates.k8s.io "kong-control-plane.kong.svc" deleted

kubectl -n kong apply -f postgres.yaml

service/postgres created

replicationcontroller/postgres created

kubectl -n kong apply -f kong-control-plane-postgres.yaml

serviceaccount/kong created

role.rbac.authorization.k8s.io/kong created

rolebinding.rbac.authorization.k8s.io/kong created

deployment.apps/kong-control-plane created

service/kong-control-plane created

job.batch/kong-control-plane-bootstrap created

kubectl -n kong apply -f kong-ingress-data-plane-postgres.yaml

deployment.apps/kong-ingress-data-plane created

service/kong-ingress-data-plane created



Now need to run some extra steps for kong-ee trial with postgres.
Find the tgz bundle we saved from our kong-ee trial email, and load the docker images from it:
$ docker load -i kong-enterprise-edition-ft-0.36.tar.gz

Loaded image: kong-docker-kong-free-trials-enterprise-edition-docker.bintray.io/kong-enterprise-edition:0.36-centos

14, check the docker image has been loaded:



$ docker images | grep kong | grep trial

kong-docker-kong-free-trials-enterprise-edition-docker.bintray.io/kong-enterprise-edition   0.36-centos         2e866b045a23        2 months ago        452MB



Note the image name and the tag of this image.


Back into the unzipped repo folder to Add your Kong Enterprise License File
Edit kong_trial_postgres.yaml and kong_trial_migration_postgres.yaml to replace YOUR_LICENSE_HERE with your Kong Enterprise License File string - it should look like:
 - name: KONG_LICENSE_DATA
  value: '{"license":{"signature":"alongstringofcharacters","payload":{"customer":"Test Company","license_creation_date":"2018-03-06","product_subscription":"Kong Only","admin_seats":"5","support_plan":"Premier","license_expiration_date":"2018-06-04","license_key":"anotherstringofcharacters"},"version":1}}'
The license text comes from the license json file we saved from the kong-ee trial email above.

Don’t forget the quotes either side of the license data



We now need to set the kong-ee docker image in the same files, so edit kong_trial_postgres.yaml and kong_trial_migration_postgres.yaml and replace :
image: kong-ee
with 
        image: kong-docker-kong-free-trials-enterprise-edition-docker.bintray.io/kong-enterprise-edition:0.36-centos
Also need to add the following missing ‘selector’ section into kong_trial_postgres.yaml
apiVersion: apps/v1

kind: Deployment

metadata:

  name: kong-rc

spec:

  replicas: 3

  selector:         <<<<

    matchLabels:    <<<<

      app: kong     <<<<

  template:

    metadata:



One last change in these files, edit kong_trial_migration_postgres.yaml. 



Find:

 - name: KONG_PG_HOST

   value: postgres.{namespace}.svc.cluster.local



And set as : 

 - name: KONG_PG_HOST

   value: postgres.kong.svc.cluster.local





With these changes, we can now apply them to our k8s cluster.





Get access to the Kong Admin API port

$ export HOST=$(kubectl get nodes --namespace default -o jsonpath='{.items[0].status.addresses[0].address}')

$ export ADMIN_PORT=$(kubectl get svc --namespace kong kong-control-plane  -o jsonpath='{.spec.ports[0].nodePort}')

export ADMIN_PORT=8001





Deploy Kong Enterprise

You will need to deploy the kong_trial_* YAML files in the Kong Enterprise Trial directory. using:

 kubectl apply -n kong -f ee-trial/kong_trial_migration_postgres.yaml

 kubectl apply -n kong -f ee-trial/kong_trial_postgres.yaml






