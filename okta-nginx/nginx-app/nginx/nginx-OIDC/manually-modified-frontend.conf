# This is the backend application we are protecting with OpenID Connect
upstream backend {
    zone backend 64k;
    #server 10.0.0.1:80;
    # remember docker & localhost wont work here unless your backend is in same docker container as nginx 
    # 172.19.11.6 = IP of wifi interface of works dell laptop
    server 172.19.11.6:7777;
}

# Custom log format to include the 'sub' claim in the REMOTE_USER field
log_format main_jwt '$remote_addr - $jwt_claim_sub [$time_local] "$request" $status '
                    '$body_bytes_sent "$http_referer" "$http_user_agent" "$http_x_forwarded_for"';

# JavaScript code for OpenID Connect
js_include conf.d/openid_connect.js;
js_set $requestid_hash hashRequestId;
auth_jwt_claim_set $jwt_audience aud; # In case aud is an array

#keyval_zone zone=opaque_sessions:1M state=conf.d/opaque_sessions.json timeout=1h; # CHANGE timeout to JWT/exp validity period
#keyval_zone zone=refresh_tokens:1M  state=conf.d/refresh_tokens.json  timeout=8h; # CHANGE timeout to refresh validity period
keyval_zone zone=opaque_sessions:1M state=/nginx-sessions/opaque_sessions.json timeout=1h; # CHANGE timeout to JWT/exp validity period
keyval_zone zone=refresh_tokens:1M  state=/nginx-sessions/refresh_tokens.json  timeout=8h; # CHANGE timeout to refresh validity period

keyval $cookie_auth_token $session_jwt zone=opaque_sessions;  # Exchange cookie for JWT
keyval $cookie_auth_token $refresh_token zone=refresh_tokens; # Exchange cookie for refresh token
keyval $request_id $new_session zone=opaque_sessions; # For initial session creation
keyval $request_id $new_refresh zone=refresh_tokens;  # "

map $refresh_token $no_refresh {
    "" 1;  # Before login
    "-" 1; # After logout
    default 0;
}

# JWK Set will be fetched from $oidc_jwks_uri and cached here - ensure writable by nginx user
proxy_cache_path /var/cache/nginx/jwk levels=1 keys_zone=jwk:64k max_size=1m;


# The frontend server - reverse proxy with OpenID Connect authentication
#
server {
    include conf.d/openid_connect.server_conf; # Authorization code flow and Relying Party processing

    # OpenID Connect Provider (IdP) configuration
    resolver 8.8.8.8; # For DNS lookup of IdP endpoints;
    subrequest_output_buffer_size 32k; # To fit a complete tokenset response

    #set $oidc_jwt_keyfile     /etc/nginx/my_idp_jwk.json; # URL when using 'auth_jwt_key_request'
    set $oidc_jwt_keyfile "https://dev-424995.okta.com/oauth2/default/v1/keys"; # URL when using 'auth_jwt_key_request'
    set $oidc_logout_redirect "/_logout"; # Where to send browser after requesting /logout location
    set $oidc_authz_endpoint "https://dev-424995.okta.com/oauth2/default/v1/authorize";
    set $oidc_token_endpoint "https://dev-424995.okta.com/oauth2/default/v1/token";
    set $oidc_client "0oa1mjs256xq3tKmN357";
    set $oidc_client_secret "XaewflSG_nlmMm07971BHd69Qj-fTrqdQXtN2xwd";
    set $oidc_token_type "id_token";
    set $oidc_hmac_key "cf832ah"; # This should be unique for every NGINX instance/cluster

    listen 8010; # Use SSL/TLS in production
    
    location / {
        # This site is protected with OpenID Connect
        auth_jwt "" token=$session_jwt;
        #auth_jwt_key_request /https://dev-424995.okta.com/oauth2/v1/keys; 
        auth_jwt_key_request /_jwks_uri; # Enable when using URL

        # Absent/invalid OpenID Connect token will (re)start auth process (including refresh)
        error_page 401 = @oidc_auth;

        # Successfuly authenticated users are proxied to the backend,
        # with 'sub' claim passed as HTTP header
        proxy_set_header username $jwt_claim_sub;
        proxy_set_header ajg-remoteaddr $remote_addr;
        proxy_set_header ajg-audience $jwt_audience;
        proxy_set_header ajg-args $args;
        proxy_pass http://backend; # The backend site/app
        
        access_log /var/log/nginx/access.log main_jwt;
    }
}

# vim: syntax=nginx
